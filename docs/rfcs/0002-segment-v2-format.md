# RFC-0002 — Segment V2 (binary, mmap, block-postings)

**Статус:** Draft  
**Версия формата сегмента:** `2`  
**Контекст:** развитие V1 (JSON файлы `grams.json`, `field_masks.json`, `docs.jsonl`, `meta.json`).  
**Цели:** компактность, быстрый холодный старт, детерминированные смещения, проверка целостности.

---

## 1) Цели и принципы

- Размер сегмента **≤ 35%** от V1 на тех же данных.
- Холодный старт **в 2× быстрее** V1 (без JSON-парсинга; только `mmap` и бинарные сканы).
- `prefilter()` выполняется **без heap-аллокаций**, итераторы поверх `mmap`.
- Единый бинарный формат с **чёткой проверкой целостности** (CRC64 для файла, CRC32 для блоков).
- Back-compat: V1 reader остаётся, выбор формата — на этапе сборки.

---

## 2) Макет каталога сегмента

```
SEGDIR/
├─ meta.bin # заголовок/инвентарь сегмента + CRC64
├─ grams.idx # индекс 3-грамм → указатели в grams.dat + CRC64
├─ grams.dat # постинги doc_id (блочные/inline) + CRC64
├─ fields.idx # словарь имён полей и указатели в fields.dat + CRC64
├─ fields.dat # битмапы doc_id по полям (Roaring/tiny) + CRC64
└─ docs.dat # блоки документов (строки UTF-8) + CRC32 per-block + CRC64
```


**Эндианность:** little-endian.  
**Выравнивание:** все `offset/len` кратны 8 байт. Паддинг — `0x00`.

---

## 3) Типы и обозначения

| Тип           | Описание                                  |
|---------------|--------------------------------------------|
| `DocId`       | `u32`                                      |
| `GramKey`     | `[u8; 3]` — три символа **нормализованной** строки |
| `FieldId`     | `u32` — индекс имени в словаре `fields.idx` |
| `Offset/Len`  | `u64` — байтовое смещение/длина            |
| Varint        | LEB128 без знака                           |

**Нормализация строк:** та же, что в V1 (`normalize()`).

---

## 4) `meta.bin` — инвентарь сегмента

| Смещение | Тип   | Поле             | Комментарий                            |
|----------|-------|------------------|----------------------------------------|
| 0x00     | u32   | `magic`          | `0x475A5347` = `"GZSG"`                |
| 0x04     | u16   | `version`        | `2`                                    |
| 0x06     | u16   | `header_len`     | размер заголовка, сейчас `48`          |
| 0x08     | u64   | `doc_count`      | кол-во документов                      |
| 0x10     | u64   | `gram_count`     | уникальных 3-грамм                      |
| 0x18     | u64   | `grams_idx_len`  | байт                                   |
| 0x20     | u64   | `grams_dat_len`  | байт                                   |
| 0x28     | u64   | `fields_idx_len` | байт                                   |
| 0x30     | u64   | `fields_dat_len` | байт                                   |
| 0x38     | u64   | `docs_dat_len`   | байт                                   |
| ...      |       | `reserved`       | до `header_len`, нули                   |
| EOF-8    | u64   | `crc64_ecma`     | CRC64-ECMA всего файла **кроме** CRC64 |

**MUST:** при открытии проверять `magic`, `version`, размеры и CRC64.

---

## 5) `grams.idx` — индекс 3-грамм

**Header:**

| Тип  | Поле        | Значение                                   |
|------|-------------|---------------------------------------------|
| u32  | `magic`     | `0x475A4944` = `"GZID"`                     |
| u16  | `version`   | `1`                                         |
| u16  | `flags`     | `0`                                         |
| u32  | `count`     | `= gram_count` из `meta.bin`                |
| u32  | `record_len`| `3 + 8 + 8 = 19` → выравниваем до 24 байт   |

**Record (выравнен до 24 байт):**

| Поле            | Тип     | Комментарий                      |
|-----------------|---------|----------------------------------|
| `key`           | [u8;3]  | 3-грамма (после `normalize()`)   |
| `offset`        | u64     | байтовое смещение в `grams.dat`  |
| `length`        | u64     | длина байт в `grams.dat`         |
| `pad`           | [u8;5]  | нули до 24                       |

**Footer:** `u64 crc64_ecma`.

**Поиск:** бинарный; ключи в лексикографическом порядке.

---

## 6) `grams.dat` — постинги DocId

Каждая запись, адресуемая `offset/length` из `grams.idx`, имеет общий префикс:

| Поле        | Тип | Комментарий                              |
|-------------|-----|-------------------------------------------|
| `kind`      | u8  | 1 = inline, 2 = блоки                     |
| `doc_count` | u32 | число DocId (для обоих видов)             |

### 6.1 Inline (kind=1)

Дальше идёт **ровно** `doc_count` значений:

```
varint first_docid
repeat (doc_count-1):
varint delta (>0)
```


Где `doc[i] = doc[i-1] + delta`. Для малых списков экономичнее и быстрее.

### 6.2 Block-compressed (kind=2)

Последовательно записаны блоки, пока не набрано `doc_count` DocId:

| Поле           | Тип  | Комментарий                                       |
|----------------|------|----------------------------------------------------|
| `base`         | u32  | первый DocId блока                                 |
| `n`            | u16  | сколько DocId в блоке (включая base)               |
| `codec`        | u8   | `1` = delta-varint                                 |
| `payload_len`  | u32  | байт в payload                                     |
| `payload`      | ...  | varint deltas для **(n-1)** элементов              |

**Рекомендация:** размер блока ≈ 8192 DocId (не жестко).

**MUST:** суммарно по блокам получить `doc_count` значений.

**Footer файла:** `u64 crc64_ecma`.

---

## 7) `fields.idx` / `fields.dat` — маски полей (A2 → V2)

### 7.1 `fields.idx`

**Header:**

| Поле            | Тип | Комментарий                       |
|-----------------|-----|-----------------------------------|
| `magic`         | u32 | `0x475A4649` = `"GZFI"`           |
| `version`       | u16 | `1`                               |
| `flags`         | u16 | `0`                               |
| `field_count`   | u32 | количество имён                   |
| `name_dict_len` | u32 | длина секции имён                 |

**Секция имён (name_dict):** подряд  
`[ varint name_len ][ name_bytes UTF-8 ]` × `field_count`  
**Порядок имён задаёт `FieldId` (0..field_count-1)**.

**Records (по одному на поле, в порядке FieldId):**

| Поле       | Тип | Комментарий                     |
|------------|-----|---------------------------------|
| `field_id` | u32 | 0..                              |
| `offset`   | u64 | в `fields.dat`                  |
| `length`   | u64 | байт в `fields.dat`             |

**Footer:** `u64 crc64_ecma`.

### 7.2 `fields.dat`

Каждая запись по `offset/length` имеет заголовок:

| Поле   | Тип | Комментарий                                 |
|--------|-----|----------------------------------------------|
| `kind` | u8  | `1` = roaring_stream, `2` = tiny_set         |

- **kind=1 (`roaring_stream`)**:  
  `u32 payload_len` + `payload` — байты `croaring` сериализации.

- **kind=2 (`tiny_set`)**:  
  `u8 n (≤ 8)` + `n * u32 doc_id` (отсортированы).

**Footer файла:** `u64 crc64_ecma`.

---

## 8) `docs.dat` — блоки документов (stored fields)

**Header:**

| Поле     | Тип | Комментарий                 |
|----------|-----|-----------------------------|
| `magic`  | u32 | `0x475A444F` = `"GZDO"`     |
| `version`| u16 | `1`                         |
| `flags`  | u16 | `0`                         |

**Далее — повторяющиеся блоки:**

| Поле         | Тип  | Комментарий                                       |
|--------------|------|----------------------------------------------------|
| `block_len`  | u32  | длина блока **после** этого поля                   |
| `first_id`   | u32  | DocId первого документа в блоке                    |
| `n_docs`     | u32  | число документов в блоке                           |
| `docs[]`     | ...  | записи документов (см. ниже)                       |
| `crc32`      | u32  | CRC32 блока (от `first_id` до конца docs[])        |

**Запись документа (для i от 0 до n_docs-1):**

| Поле          | Тип     | Комментарий                                                |
|---------------|---------|------------------------------------------------------------|
| `field_cnt`   | u16     | сколько полей хранится                                     |
| Повтор `field_cnt` раз: |  |                                                        |
| `field_id`    | varint  | индекс в `fields.idx` name_dict                            |
| `val_len`     | varint  | длина значения                                             |
| `val_bytes`   | [u8]    | UTF-8 нормализованная строка                               |

**DocId документа:** `first_id + i` (не хранится отдельно).  
**Footer файла:** `u64 crc64_ecma`.

---

## 9) Reader API (V2) — инварианты

- `open_segment(path)` **MUST**:
  - проверить все magic/version/CRC,
  - `mmap` файлы read-only,
  - подготовить быстрые чтения `grams.idx/dat`, `fields.idx/dat`.
- `prefilter(BooleanOp, grams[], field_opt)` **MUST**:
  - для каждого `GramKey` найти запись в `grams.idx`,
  - итерировать `DocId` по `grams.dat` без аллокаций,
  - комбинировать по `And/Or/Not`,
  - если `field_opt` — пересечь с битмапой из `fields.dat`.
- `get_doc(doc_id)` **MUST**:
  - найти блок по `first_id/n_docs`,
  - извлечь поля указанного документа,
  - вернуть ссылки/копии (решение за реализацией; важна сложность ~O(1) по блоку).

---

## 10) Writer (V2) — требования

- Сборка: из `docs.jsonl` (как V1) → те же правила нормализации.
- Постинги: хранить отсортированные `DocId`. Выбор inline vs block:
  - inline при `doc_count ≤ 8` и `payload_len ≤ 64` байт (рекомендуется),
  - иначе — блоки ~8K.
- Маски полей: Roaring; tiny_set при `n ≤ 8`.
- Docs: определение `field_id` через `fields.idx` name_dict (единая таблица имён).
- Все указатели/длины в `meta.bin` **MUST** быть кратны 8.

---

## 11) Контроль целостности

- `meta.bin`, `grams.idx`, `grams.dat`, `fields.idx`, `fields.dat`, `docs.dat` — **CRC64-ECMA** в футере.
- Блоки в `docs.dat` — **CRC32** каждого блока.
- При несоответствии: ошибка `CorruptSegment`, отказ от открытия сегмента.

---

## 12) Совместимость

- V1 и V2 сосуществуют. Детект по наличию `meta.bin` и/или magic.
- `gzctl build-seg` принимает `--format v1|v2` (по умолчанию `v2` после стабилизации).
- `manifest.json` не меняется: указывает каталоги сегментов, формат прозрачен для брокера.

---

## 13) Acceptance Criteria

- [ ] На `examples/data.jsonl`: размер `SEGDIR` (V2) ≤ 35% размера V1.
- [ ] Первый запрос после старта быстрее V1 как минимум в 2 раза.
- [ ] `gzctl search-seg --q "*игра*" --field text.body`: хиты V1/V2 совпадают.
- [ ] Инъекция порчи `grams.dat` → ошибка `CorruptSegment` при `open_segment()`.
- [ ] Unit-тесты: varint round-trip; выбор inline vs block; roaring serialize/deserialize.
- [ ] E2E: broker (B6) ищет по V2 без изменений в broker’е.

---

## 14) Тест-план

- **Unit / codec:** varint-кодирование/декодирование, порог tiny/inline, блок-кодек.
- **Unit / idx:** бинарный поиск в `grams.idx` (границы, отсутствующие ключи).
- **Unit / fields:** tiny_set vs roaring; пересечение с префильтром.
- **E2E:** собрать V2 → `gzctl search-seg` → `/search` (B6) по shards.
- **Corruption:** побить байты в `grams.dat`/`docs.dat` → отказ `open_segment()`.

---

## 15) Миграция

- `gzctl` — добавить `--format`; по умолчанию оставить V1 до прохождения всех AC.
- После стабилизации — переключить дефолт на V2, оставить V1 флагом обратной совместимости.
- README: обновить примеры сборки/поиска; подсветить различия.

